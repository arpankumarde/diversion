"""curl_cffi TLS-safe HTTP client for exploitation."""

from __future__ import annotations

import logging
from urllib.parse import urlparse

from curl_cffi.requests import AsyncSession

from nazitest.models.exploit import ExploitResponse, ExploitStrategy

logger = logging.getLogger(__name__)


class CurlExploiter:
    """TLS-fingerprint-safe HTTP client for exploitation.

    Uses curl_cffi to impersonate real browser TLS signatures.
    Reuses a single AsyncSession for connection pooling.
    """

    def __init__(self, proxy_url: str | None = None) -> None:
        self.proxy_url = proxy_url
        self._session: AsyncSession | None = None

    async def _get_session(self, impersonate: str = "chrome131") -> AsyncSession:
        """Get or create a reusable session."""
        if self._session is None:
            proxies = (
                {"https": self.proxy_url, "http": self.proxy_url}
                if self.proxy_url
                else None
            )
            self._session = AsyncSession(
                impersonate=impersonate,
                proxies=proxies,
                verify=False,
            )
        return self._session

    async def close(self) -> None:
        """Close the underlying session."""
        if self._session is not None:
            await self._session.close()
            self._session = None

    async def execute(
        self,
        strategy: ExploitStrategy,
        cookies: dict[str, str] | None = None,
    ) -> ExploitResponse:
        """Execute an exploit strategy and return the response."""
        # Validate URL before sending to curl
        parsed = urlparse(strategy.url)
        if not parsed.scheme or not parsed.netloc:
            logger.error(
                "Invalid URL (missing scheme/host): %s",
                strategy.url,
            )
            return ExploitResponse(
                status=0,
                body=f"Invalid URL: {strategy.url}",
            )

        logger.info(
            "curl: %s %s impersonate=%s cookies=%s body=%s",
            strategy.http_method.value,
            strategy.url,
            strategy.impersonate,
            list(cookies.keys()) if cookies else "none",
            (strategy.body[:80] if strategy.body else "none"),
        )

        session = await self._get_session(strategy.impersonate)

        # Set cookies
        if cookies:
            for name, value in cookies.items():
                session.cookies.set(name, value)

        try:
            response = await session.request(
                method=strategy.http_method.value,
                url=strategy.url,
                headers=strategy.headers or None,
                data=strategy.body.encode() if strategy.body else None,
                params=strategy.params or None,
                allow_redirects=strategy.follow_redirects,
                timeout=strategy.timeout,
            )

            return ExploitResponse(
                status=response.status_code,
                headers=dict(response.headers),
                body=response.text[:50000],  # Cap body size
                elapsed_ms=(
                    response.elapsed.total_seconds() * 1000
                    if response.elapsed
                    else 0
                ),
                tls_version=(
                    str(response.http_version)
                    if hasattr(response, "http_version") else ""
                ),
            )
        except Exception as e:
            logger.error("Exploit request failed: %s", e)
            return ExploitResponse(
                status=0,
                body=f"Error: {e}",
            )
