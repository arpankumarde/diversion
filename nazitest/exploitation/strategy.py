"""Strategy rotation â€” encoding, delivery, timing, identity rotation per PRD section 9."""

from __future__ import annotations

import random
from typing import Any

from nazitest.models.types import DeliveryMethod, EncodingType


class StrategyRotator:
    """Rotates encoding, delivery, and identity strategies when exploits are blocked."""

    ENCODINGS = list(EncodingType)
    DELIVERIES = list(DeliveryMethod)
    TLS_FINGERPRINTS = [
        "chrome",
        "chrome131",
        "chrome124",
        "chrome99",
        "safari",
    ]
    USER_AGENTS = [
        (
            "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36"
            " (KHTML, like Gecko) Chrome/136.0.0.0 Safari/537.36"
        ),
        (
            "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36"
            " (KHTML, like Gecko) Chrome/136.0.0.0 Safari/537.36"
        ),
        (
            "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:133.0)"
            " Gecko/20100101 Firefox/133.0"
        ),
        (
            "Mozilla/5.0 (Macintosh; Intel Mac OS X 14_7) AppleWebKit/605.1.15"
            " (KHTML, like Gecko) Version/18.0 Safari/605.1.15"
        ),
        (
            "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36"
            " (KHTML, like Gecko) Chrome/136.0.0.0 Safari/537.36"
        ),
    ]

    def __init__(self) -> None:
        self._used_encodings: list[EncodingType] = []
        self._used_deliveries: list[DeliveryMethod] = []
        self._used_fingerprints: list[str] = []

    def next_encoding(self) -> EncodingType:
        """Get next encoding that hasn't been tried yet."""
        available = [e for e in self.ENCODINGS if e not in self._used_encodings]
        if not available:
            self._used_encodings.clear()
            available = list(self.ENCODINGS)
        choice = random.choice(available)
        self._used_encodings.append(choice)
        return choice

    def next_delivery(self) -> DeliveryMethod:
        """Get next delivery method that hasn't been tried yet."""
        available = [d for d in self.DELIVERIES if d not in self._used_deliveries]
        if not available:
            self._used_deliveries.clear()
            available = list(self.DELIVERIES)
        choice = random.choice(available)
        self._used_deliveries.append(choice)
        return choice

    def next_fingerprint(self) -> str:
        """Get next TLS fingerprint to impersonate."""
        available = [f for f in self.TLS_FINGERPRINTS if f not in self._used_fingerprints]
        if not available:
            self._used_fingerprints.clear()
            available = list(self.TLS_FINGERPRINTS)
        choice = random.choice(available)
        self._used_fingerprints.append(choice)
        return choice

    def next_user_agent(self) -> str:
        """Get a random user agent string."""
        return random.choice(self.USER_AGENTS)

    def get_rotation(self) -> dict[str, Any]:
        """Get a complete rotation set for the next attempt."""
        return {
            "encoding": self.next_encoding(),
            "delivery": self.next_delivery(),
            "fingerprint": self.next_fingerprint(),
            "user_agent": self.next_user_agent(),
        }

    def reset(self) -> None:
        self._used_encodings.clear()
        self._used_deliveries.clear()
        self._used_fingerprints.clear()
