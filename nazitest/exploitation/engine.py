"""Exploitation engine — manages exploit attempts with smart detection."""

from __future__ import annotations

import html
import logging
import re

from nazitest.exploitation.backoff import BackoffManager
from nazitest.exploitation.curl_exploit import CurlExploiter
from nazitest.exploitation.strategy import StrategyRotator
from nazitest.models.exploit import (
    ExploitAttempt,
    ExploitResponse,
    ExploitResult,
    ExploitStrategy,
)

logger = logging.getLogger(__name__)

# ── Vulnerability-specific detection indicators ──

SQL_ERROR_PATTERNS = [
    r"you have an error in your sql syntax",
    r"unclosed quotation mark",
    r"quoted string not properly terminated",
    r"mysql_fetch",
    r"pg_query",
    r"sqlite3?\.",
    r"ORA-\d{5}",
    r"Microsoft OLE DB Provider",
    r"ODBC SQL Server Driver",
    r"syntax error at or near",
    r"unterminated string",
    r"SQL syntax.*MySQL",
    r"Warning.*mysql_",
    r"valid MySQL result",
    r"MySqlClient\.",
    r"PostgreSQL.*ERROR",
    r"supplied argument is not a valid",
    r"com\.mysql\.jdbc",
    r"Syntax error.*in query expression",
    r"SQLSTATE\[",
    r"Unclosed quotation mark after",
    r"org\.postgresql\.util\.PSQLException",
    r"com\.microsoft\.sqlserver\.jdbc",
]

SQL_DATA_LEAK_PATTERNS = [
    r"admin.*password",
    r"root:.*:0:0",
    r"information_schema",
    r"table_name.*column_name",
    r"UNION.*SELECT",
]

XSS_REFLECTION_MARKERS = [
    "<script>alert(", "javascript:", "onerror=",
    "onload=", "onfocus=", "<img src=x",
    "<svg ", "alert(1)", "prompt(", "confirm(",
    "document.cookie", "document.domain",
]

PATH_TRAVERSAL_INDICATORS = [
    "root:x:0:0", "[boot loader]",
    "[operating systems]", "<!DOCTYPE plist",
    "[extensions]", "for 16-bit app support",
]

COMMAND_INJECTION_PATTERNS = [
    r"uid=\d+\(.*?\)\s+gid=\d+",
    r"Linux \S+ \d+\.\d+",
    r"total \d+\ndrwx",
    r"Volume Serial Number",
    r"Directory of [A-Z]:\\",
]


class ExploitationEngine:
    """Orchestrates exploit attempts with differential detection.

    Key insight: real scanners (sqlmap, etc.) compare payload
    responses against a BASELINE. A successful SQLi doesn't
    throw errors — it returns extra data. We detect that by
    comparing response size/content against a benign request.

    Two modes:
    - Single-shot: try one request, no retries.
    - With retry: retry with rotation on block.
    """

    def __init__(
        self,
        curl_exploiter: CurlExploiter | None = None,
        max_attempts: int = 3,
    ) -> None:
        self.curl = curl_exploiter or CurlExploiter()
        self.max_attempts = max_attempts
        self.backoff = BackoffManager(max_delay=5.0)
        self.rotator = StrategyRotator()
        # Cache baselines per (url, method) to avoid repeat
        self._baselines: dict[str, ExploitResponse] = {}

    async def get_baseline(
        self,
        strategy: ExploitStrategy,
        cookies: dict[str, str] | None = None,
    ) -> ExploitResponse:
        """Fetch a baseline response with a benign value.

        Sends the same request but with a safe value instead
        of the payload. Used for differential comparison.
        """
        cache_key = (
            f"{strategy.http_method.value}:{strategy.url}"
        )
        if cache_key in self._baselines:
            return self._baselines[cache_key]

        # Build a benign version of the strategy
        benign = ExploitStrategy(
            hypothesis_id=strategy.hypothesis_id,
            http_method=strategy.http_method,
            url=strategy.url,
            headers=strategy.headers,
            body=None,
            params={},
            payload="",
            follow_redirects=strategy.follow_redirects,
            timeout=strategy.timeout,
            impersonate=strategy.impersonate,
        )

        # For GET: send with param=1 (benign value)
        if strategy.params:
            param_name = next(iter(strategy.params))
            benign.params = {param_name: "1"}
        # For POST: send with param=1
        elif strategy.body and "=" in strategy.body:
            param_name = strategy.body.split("=")[0]
            benign.body = f"{param_name}=1"
            benign.headers = {
                **strategy.headers,
                "Content-Type": (
                    "application/x-www-form-urlencoded"
                ),
            }

        logger.info(
            "Baseline: %s %s param=%s",
            benign.http_method.value,
            benign.url,
            benign.params or benign.body or "none",
        )

        response = await self.curl.execute(benign, cookies)
        logger.info(
            "  Baseline: status=%d body_len=%d",
            response.status,
            len(response.body),
        )

        self._baselines[cache_key] = response
        return response

    async def single_shot(
        self,
        strategy: ExploitStrategy,
        cookies: dict[str, str] | None = None,
        vuln_type: str = "",
        baseline: ExploitResponse | None = None,
    ) -> ExploitResult:
        """Execute ONE request, no retries."""
        payload = strategy.payload

        logger.info(
            "Single-shot: %s %s payload=%s cookies=%s",
            strategy.http_method.value,
            strategy.url,
            payload[:60],
            list(cookies.keys()) if cookies else "none",
        )

        response = await self.curl.execute(strategy, cookies)

        body_preview = response.body[:200].replace("\n", " ")
        logger.info(
            "  → status=%d body_len=%d preview=%s",
            response.status,
            len(response.body),
            body_preview,
        )

        attempt = ExploitAttempt(
            attempt_number=1,
            strategy=strategy,
            response=response,
        )

        confirmed, evidence = self._detect_vuln(
            response, vuln_type, payload, baseline
        )

        if confirmed:
            logger.info(
                "  → CONFIRMED: %s", evidence[:200]
            )
            attempt.success = True
            return ExploitResult(
                hypothesis_id=strategy.hypothesis_id,
                confirmed=True,
                attempts=[attempt],
                poc_script=strategy.to_poc_script(),
                evidence_summary=evidence,
            )

        blocked = self._is_blocked(
            response.status, response.body
        )
        if blocked:
            attempt.blocked = True
            logger.info(
                "  → BLOCKED (status=%d)", response.status
            )
        else:
            attempt.inconclusive = True
            logger.info("  → inconclusive")

        return ExploitResult(
            hypothesis_id=strategy.hypothesis_id,
            confirmed=False,
            attempts=[attempt],
            evidence_summary=evidence,
        )

    async def exploit(
        self,
        strategy: ExploitStrategy,
        cookies: dict[str, str] | None = None,
        vuln_type: str = "",
        baseline: ExploitResponse | None = None,
    ) -> ExploitResult:
        """Execute with retry and rotation on block."""
        attempts: list[ExploitAttempt] = []
        payload = strategy.payload

        for attempt_num in range(self.max_attempts):
            current = (
                strategy
                if attempt_num == 0
                else self._rotate_strategy(strategy)
            )

            logger.info(
                "Attempt %d/%d: %s %s payload=%s",
                attempt_num + 1,
                self.max_attempts,
                current.http_method.value,
                current.url,
                payload[:60],
            )

            response = await self.curl.execute(
                current, cookies
            )

            body_preview = response.body[:200].replace(
                "\n", " "
            )
            logger.info(
                "  → status=%d body_len=%d preview=%s",
                response.status,
                len(response.body),
                body_preview,
            )

            attempt = ExploitAttempt(
                attempt_number=attempt_num + 1,
                strategy=current,
                response=response,
            )

            confirmed, evidence = self._detect_vuln(
                response, vuln_type, payload, baseline
            )

            if confirmed:
                logger.info(
                    "  → CONFIRMED: %s", evidence[:200]
                )
                attempt.success = True
                attempts.append(attempt)
                return ExploitResult(
                    hypothesis_id=strategy.hypothesis_id,
                    confirmed=True,
                    attempts=attempts,
                    poc_script=strategy.to_poc_script(),
                    evidence_summary=evidence,
                )

            if self._is_blocked(
                response.status, response.body
            ):
                attempt.blocked = True
                attempts.append(attempt)
                logger.info(
                    "  → BLOCKED (status=%d), backing off",
                    response.status,
                )
                await self.backoff.wait(attempt_num)
                continue

            attempt.inconclusive = True
            attempts.append(attempt)
            logger.info("  → inconclusive, no retry")
            break

        return ExploitResult(
            hypothesis_id=strategy.hypothesis_id,
            confirmed=False,
            attempts=attempts,
        )

    def _detect_vuln(
        self,
        response: ExploitResponse,
        vuln_type: str,
        payload: str = "",
        baseline: ExploitResponse | None = None,
    ) -> tuple[bool, str]:
        """Detect if response confirms a vulnerability.

        Uses BOTH signature-based AND differential detection:
        1. Signature: known error patterns, markers
        2. Differential: compare against baseline response
        3. Time-based: check elapsed_ms for sleep payloads
        """
        if response.status == 0:
            return False, ""

        body = response.body
        body_lower = body.lower()
        # HTML-decode for payload reflection checks
        body_decoded = html.unescape(body)

        vt = vuln_type.lower().replace(
            "-", ""
        ).replace("_", "")
        logger.debug(
            "  detect: vt=%s body_len=%d baseline=%s",
            vt,
            len(body),
            len(baseline.body) if baseline else "none",
        )

        is_sqli = any(
            x in vt
            for x in ("sqli", "sqlinjection", "sql", "blind",
                       "union")
        )

        # ── SQL Injection ──
        if is_sqli:
            # 1. Error-based
            for pattern in SQL_ERROR_PATTERNS:
                m = re.search(pattern, body, re.I)
                if m:
                    return True, (
                        f"SQL error: {m.group()[:100]}"
                    )
            # 2. Data leak patterns
            for pattern in SQL_DATA_LEAK_PATTERNS:
                m = re.search(pattern, body, re.I)
                if m:
                    return True, (
                        f"SQL data leak: {m.group()[:100]}"
                    )
            # 3. Differential: response significantly larger
            #    than baseline = data extraction
            if baseline and baseline.status != 0:
                bl = len(baseline.body)
                rl = len(body)
                if bl > 0 and rl > bl * 1.5 and rl - bl > 200:
                    return True, (
                        f"Response size anomaly: "
                        f"baseline={bl}b, payload={rl}b "
                        f"(+{rl - bl}b / "
                        f"+{((rl - bl) / bl * 100):.0f}%)"
                    )
            # 4. Boolean-based: response differs from baseline
            #    for AND 1=1 vs AND 1=2 style payloads
            if baseline and baseline.status != 0:
                bl = len(baseline.body)
                rl = len(body)
                # "AND 1=2" or "AND '1'='2" should return
                # smaller/empty response vs baseline
                if any(
                    x in payload
                    for x in ("1=2", "'1'='2", "1=0")
                ):
                    if bl > 0 and rl < bl * 0.7:
                        return True, (
                            f"Boolean SQLi: AND-false shrinks "
                            f"response ({bl}b → {rl}b)"
                        )
                # "OR 1=1" or "OR '1'='1'" should return
                # larger response (all rows)
                elif any(
                    x in payload
                    for x in ("OR 1=1", "OR '1'='1",
                              "OR 1#", "OR 1--")
                ):
                    if bl > 0 and rl > bl * 1.3:
                        return True, (
                            f"Boolean SQLi: OR-true expands "
                            f"response ({bl}b → {rl}b)"
                        )
            # 5. Time-based: SLEEP/WAITFOR payloads
            if any(
                x in payload.upper()
                for x in ("SLEEP(", "WAITFOR", "DELAY",
                           "PG_SLEEP", "BENCHMARK(")
            ):
                if response.elapsed_ms > 4000:
                    return True, (
                        f"Time-based SQLi: "
                        f"{response.elapsed_ms:.0f}ms "
                        f"(sleep payload)"
                    )

        # ── XSS ──
        if any(
            x in vt
            for x in ("xss", "crosssite", "reflected", "dom")
        ):
            # Check decoded body for payload reflection
            if payload and payload in body_decoded:
                return True, (
                    f"Payload reflected: {payload[:80]}"
                )
            # Also check raw body
            if payload and payload in body:
                return True, (
                    f"Payload reflected (raw): "
                    f"{payload[:80]}"
                )
            for marker in XSS_REFLECTION_MARKERS:
                if marker.lower() in body_lower:
                    return True, (
                        f"XSS indicator: {marker}"
                    )

        # ── Path Traversal ──
        if any(
            x in vt
            for x in (
                "pathtraversal", "lfi", "rfi",
                "fileinclude", "directorytraversal",
            )
        ):
            for indicator in PATH_TRAVERSAL_INDICATORS:
                if indicator in body:
                    return True, (
                        f"File content: {indicator}"
                    )

        # ── Command Injection ──
        if any(
            x in vt
            for x in (
                "cmdi", "commandinjection",
                "rce", "oscommand",
            )
        ):
            for pattern in COMMAND_INJECTION_PATTERNS:
                m = re.search(pattern, body)
                if m:
                    return True, (
                        f"Command output: {m.group()[:100]}"
                    )
            # Differential for cmdi too
            if baseline and baseline.status != 0:
                bl = len(baseline.body)
                rl = len(body)
                if bl > 0 and rl > bl * 1.5 and rl - bl > 100:
                    return True, (
                        f"Command output size anomaly: "
                        f"baseline={bl}b, payload={rl}b"
                    )

        # ── CSRF ──
        if "csrf" in vt:
            if 200 <= response.status < 400:
                if "token" not in body_lower:
                    return True, "No CSRF token, action OK"

        # ── Generic scan (all indicators) ──
        for pattern in SQL_ERROR_PATTERNS:
            m = re.search(pattern, body, re.I)
            if m:
                return True, (
                    f"SQL error (generic): {m.group()[:100]}"
                )

        # Payload reflection (decoded)
        if payload and len(payload) > 3:
            if payload in body_decoded:
                return True, (
                    f"Payload reflected: {payload[:80]}"
                )

        for pattern in COMMAND_INJECTION_PATTERNS:
            m = re.search(pattern, body)
            if m:
                return True, (
                    f"Cmd output (generic): "
                    f"{m.group()[:100]}"
                )

        return False, ""

    def _rotate_strategy(
        self, original: ExploitStrategy
    ) -> ExploitStrategy:
        rotation = self.rotator.get_rotation()
        return ExploitStrategy(
            hypothesis_id=original.hypothesis_id,
            method=original.method,
            http_method=original.http_method,
            url=original.url,
            headers={
                **original.headers,
                "User-Agent": rotation["user_agent"],
            },
            body=original.body,
            params=original.params,
            payload=original.payload,
            encoding=rotation["encoding"],
            delivery=rotation["delivery"],
            follow_redirects=original.follow_redirects,
            timeout=original.timeout,
            impersonate=rotation["fingerprint"],
            description=(
                f"Rotated: {rotation['encoding'].value} "
                f"via {rotation['delivery'].value}"
            ),
        )

    @staticmethod
    def _is_blocked(status: int, body: str) -> bool:
        """Detect WAF/security blocks."""
        if status in (403, 406, 429, 503):
            return True
        if len(body) > 2000:
            return False
        blocked_indicators = [
            "blocked by",
            "rate limit exceeded",
            "waf block",
            "access denied",
            "request blocked",
        ]
        body_lower = body.lower()
        return any(ind in body_lower for ind in blocked_indicators)
