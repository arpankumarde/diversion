"""Exploitation engine — manages exploit attempts with smart detection."""

from __future__ import annotations

import logging
import re

from nazitest.exploitation.backoff import BackoffManager
from nazitest.exploitation.curl_exploit import CurlExploiter
from nazitest.exploitation.strategy import StrategyRotator
from nazitest.models.exploit import (
    ExploitAttempt,
    ExploitResponse,
    ExploitResult,
    ExploitStrategy,
)

logger = logging.getLogger(__name__)

# ── Vulnerability-specific detection indicators ──

SQL_ERROR_PATTERNS = [
    r"you have an error in your sql syntax",
    r"unclosed quotation mark",
    r"quoted string not properly terminated",
    r"mysql_fetch",
    r"pg_query",
    r"sqlite3?\.",
    r"ORA-\d{5}",
    r"Microsoft OLE DB Provider",
    r"ODBC SQL Server Driver",
    r"syntax error at or near",
    r"unterminated string",
    r"SQL syntax.*MySQL",
    r"Warning.*mysql_",
    r"valid MySQL result",
    r"MySqlClient\.",
    r"PostgreSQL.*ERROR",
    r"supplied argument is not a valid",
    r"com\.mysql\.jdbc",
    r"Syntax error.*in query expression",
    r"SQLSTATE\[",
    r"Unclosed quotation mark after",
    r"org\.postgresql\.util\.PSQLException",
    r"com\.microsoft\.sqlserver\.jdbc",
]

SQL_DATA_LEAK_PATTERNS = [
    r"admin.*password",
    r"root:.*:0:0",
    r"information_schema",
    r"table_name.*column_name",
    r"UNION.*SELECT",
]

XSS_REFLECTION_MARKERS = [
    "<script>",
    "javascript:",
    "onerror=",
    "onload=",
    "onfocus=",
    "<img src=x",
    "<svg ",
    "alert(",
    "prompt(",
    "confirm(",
    "document.cookie",
    "document.domain",
]

PATH_TRAVERSAL_INDICATORS = [
    "root:x:0:0",
    "[boot loader]",
    "[operating systems]",
    "<!DOCTYPE plist",
    "<?xml version",
    "[extensions]",
    "for 16-bit app support",
]

SSRF_INDICATORS = [
    "127.0.0.1",
    "localhost",
    "internal",
    "169.254.169.254",
    "metadata.google.internal",
]

IDOR_INDICATORS = [
    "unauthorized",
    "different user",
    "access denied",
]

COMMAND_INJECTION_PATTERNS = [
    r"uid=\d+\(.*?\)\s+gid=\d+",
    r"Linux \S+ \d+\.\d+",
    r"total \d+\ndrwx",
    r"Volume Serial Number",
    r"Directory of [A-Z]:\\",
]


class ExploitationEngine:
    """Orchestrates exploit attempts with vuln-specific detection.

    For each hypothesis:
    1. Execute with the given strategy
    2. Check response for vulnerability-specific indicators
    3. If blocked: backoff, rotate strategy, retry
    4. Support multiple strategies per hypothesis
    """

    def __init__(
        self,
        curl_exploiter: CurlExploiter | None = None,
        max_attempts: int = 8,
    ) -> None:
        self.curl = curl_exploiter or CurlExploiter()
        self.max_attempts = max_attempts
        self.backoff = BackoffManager()
        self.rotator = StrategyRotator()

    async def exploit(
        self,
        strategy: ExploitStrategy,
        cookies: dict[str, str] | None = None,
        vuln_type: str = "",
    ) -> ExploitResult:
        """Execute an exploit strategy with retry and rotation.

        Args:
            strategy: The exploit strategy to execute.
            cookies: Session cookies.
            vuln_type: Vulnerability type for smart detection
                (sqli, xss, path_traversal, ssrf, cmdi, etc.)
        """
        attempts: list[ExploitAttempt] = []
        payload = strategy.payload

        for attempt_num in range(self.max_attempts):
            current = (
                strategy
                if attempt_num == 0
                else self._rotate_strategy(strategy)
            )

            logger.info(
                "Exploit attempt %d/%d for %s "
                "(encoding=%s, delivery=%s)",
                attempt_num + 1,
                self.max_attempts,
                current.url,
                current.encoding.value,
                current.delivery.value,
            )

            response = await self.curl.execute(
                current, cookies
            )

            attempt = ExploitAttempt(
                attempt_number=attempt_num + 1,
                strategy=current,
                response=response,
            )

            # Smart detection based on vuln type
            confirmed, evidence = self._detect_vuln(
                response, vuln_type, payload
            )

            if confirmed:
                attempt.success = True
                attempts.append(attempt)
                return ExploitResult(
                    hypothesis_id=strategy.hypothesis_id,
                    confirmed=True,
                    attempts=attempts,
                    poc_script=strategy.to_poc_script(),
                    evidence_summary=evidence,
                )

            if self._is_blocked(
                response.status, response.body
            ):
                attempt.blocked = True
                attempts.append(attempt)
                await self.backoff.wait(attempt_num)
                continue

            # Not blocked, not confirmed — inconclusive
            attempt.inconclusive = True
            attempts.append(attempt)

        # After all attempts, check if we have any
        # "interesting" responses worth flagging
        best_evidence = self._find_best_evidence(
            attempts, vuln_type, payload
        )

        return ExploitResult(
            hypothesis_id=strategy.hypothesis_id,
            confirmed=False,
            attempts=attempts,
            evidence_summary=best_evidence,
        )

    def _detect_vuln(
        self,
        response: ExploitResponse,
        vuln_type: str,
        payload: str = "",
    ) -> tuple[bool, str]:
        """Detect if the response indicates a confirmed vuln.

        Returns (confirmed, evidence_summary).
        """
        if response.status == 0:
            return False, ""

        body = response.body
        body_lower = body.lower()
        vt = vuln_type.lower().replace("-", "").replace("_", "")

        # ── SQL Injection ──
        if vt in ("sqli", "sqlinjection", "sql"):
            for pattern in SQL_ERROR_PATTERNS:
                if re.search(pattern, body, re.I):
                    return True, (
                        f"SQL error detected: "
                        f"{re.search(pattern, body, re.I).group()}"
                    )
            for pattern in SQL_DATA_LEAK_PATTERNS:
                if re.search(pattern, body, re.I):
                    return True, (
                        f"SQL data leak: "
                        f"{re.search(pattern, body, re.I).group()}"
                    )

        # ── XSS ──
        if vt in ("xss", "crosssitescripting", "reflected", "dom"):
            # Check if our payload is reflected
            if payload and payload in body:
                return True, (
                    f"Payload reflected in response: "
                    f"{payload[:100]}"
                )
            for marker in XSS_REFLECTION_MARKERS:
                if marker.lower() in body_lower:
                    return True, (
                        f"XSS indicator in response: {marker}"
                    )

        # ── Path Traversal ──
        if vt in (
            "pathtraversal", "lfi", "rfi", "fileinclude",
            "directorytraversal",
        ):
            for indicator in PATH_TRAVERSAL_INDICATORS:
                if indicator in body:
                    return True, (
                        f"File content leaked: {indicator}"
                    )

        # ── SSRF ──
        if vt in ("ssrf", "serverside"):
            for indicator in SSRF_INDICATORS:
                if indicator in body_lower:
                    return True, (
                        f"SSRF indicator: {indicator}"
                    )

        # ── Command Injection ──
        if vt in (
            "cmdi", "commandinjection", "rce", "oscommand",
        ):
            for pattern in COMMAND_INJECTION_PATTERNS:
                if re.search(pattern, body):
                    return True, (
                        f"Command output detected: "
                        f"{re.search(pattern, body).group()}"
                    )

        # ── CSRF ──
        if vt in ("csrf", "crosssite"):
            if 200 <= response.status < 400:
                if "token" not in body_lower:
                    return True, (
                        "No CSRF token in response, "
                        "action succeeded"
                    )

        # ── Generic: check all indicators regardless of type ──
        for pattern in SQL_ERROR_PATTERNS:
            if re.search(pattern, body, re.I):
                return True, (
                    f"SQL error (generic scan): "
                    f"{re.search(pattern, body, re.I).group()}"
                )

        if payload and len(payload) > 3 and payload in body:
            return True, (
                f"Payload reflected (generic): "
                f"{payload[:100]}"
            )

        for pattern in COMMAND_INJECTION_PATTERNS:
            if re.search(pattern, body):
                return True, (
                    f"Command output (generic): "
                    f"{re.search(pattern, body).group()}"
                )

        return False, ""

    def _find_best_evidence(
        self,
        attempts: list[ExploitAttempt],
        vuln_type: str,
        payload: str,
    ) -> str:
        """Look through all attempts for the best evidence."""
        for attempt in attempts:
            if attempt.response and attempt.response.status:
                _, evidence = self._detect_vuln(
                    attempt.response, vuln_type, payload
                )
                if evidence:
                    return evidence
        return ""

    def _rotate_strategy(
        self, original: ExploitStrategy
    ) -> ExploitStrategy:
        """Create a rotated variant of the strategy."""
        rotation = self.rotator.get_rotation()
        return ExploitStrategy(
            hypothesis_id=original.hypothesis_id,
            method=original.method,
            http_method=original.http_method,
            url=original.url,
            headers={
                **original.headers,
                "User-Agent": rotation["user_agent"],
            },
            body=original.body,
            params=original.params,
            payload=original.payload,
            encoding=rotation["encoding"],
            delivery=rotation["delivery"],
            follow_redirects=original.follow_redirects,
            timeout=original.timeout,
            impersonate=rotation["fingerprint"],
            description=(
                f"Rotated: {rotation['encoding'].value} "
                f"via {rotation['delivery'].value}"
            ),
        )

    @staticmethod
    def _is_blocked(status: int, body: str) -> bool:
        """Determine if the response indicates blocking."""
        if status in (403, 406, 429, 503):
            return True
        blocked_indicators = [
            "blocked", "forbidden", "rate limit",
            "captcha", "waf", "firewall",
            "access denied", "not acceptable",
        ]
        body_lower = body.lower()
        return any(ind in body_lower for ind in blocked_indicators)
