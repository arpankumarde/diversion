"""Exploitation orchestrator — manages exploit attempts per hypothesis."""

from __future__ import annotations

import logging

from nazitest.exploitation.backoff import BackoffManager
from nazitest.exploitation.curl_exploit import CurlExploiter
from nazitest.exploitation.strategy import StrategyRotator
from nazitest.models.exploit import ExploitAttempt, ExploitResult, ExploitStrategy
from nazitest.models.types import ExploitMethod

logger = logging.getLogger(__name__)


class ExploitationEngine:
    """Orchestrates exploit attempts per hypothesis.

    For each confirmed hypothesis:
    1. Execute with the given strategy
    2. If blocked: backoff, rotate strategy, retry
    3. Record everything
    """

    def __init__(
        self,
        curl_exploiter: CurlExploiter | None = None,
        max_attempts: int = 5,
    ) -> None:
        self.curl = curl_exploiter or CurlExploiter()
        self.max_attempts = max_attempts
        self.backoff = BackoffManager()
        self.rotator = StrategyRotator()

    async def exploit(
        self,
        strategy: ExploitStrategy,
        cookies: dict[str, str] | None = None,
    ) -> ExploitResult:
        """Execute an exploit strategy with retry and rotation."""
        attempts: list[ExploitAttempt] = []

        for attempt_num in range(self.max_attempts):
            current_strategy = strategy if attempt_num == 0 else self._rotate_strategy(strategy)

            logger.info(
                "Exploit attempt %d/%d for %s (encoding=%s, delivery=%s)",
                attempt_num + 1,
                self.max_attempts,
                current_strategy.url,
                current_strategy.encoding.value,
                current_strategy.delivery.value,
            )

            if current_strategy.method == ExploitMethod.CURL_CFFI:
                response = await self.curl.execute(current_strategy, cookies)
            else:
                # Browser replay handled externally
                logger.warning("Browser replay not available in engine, falling back to curl")
                response = await self.curl.execute(current_strategy, cookies)

            attempt = ExploitAttempt(
                attempt_number=attempt_num + 1,
                strategy=current_strategy,
                response=response,
            )

            # Evaluate response
            if self._is_success(response.status, response.body):
                attempt.success = True
                attempts.append(attempt)
                return ExploitResult(
                    hypothesis_id=strategy.hypothesis_id,
                    confirmed=True,
                    attempts=attempts,
                    poc_script=strategy.to_poc_script(),
                    evidence_summary=f"Exploit confirmed on attempt {attempt_num + 1}",
                )

            if self._is_blocked(response.status, response.body):
                attempt.blocked = True
                attempts.append(attempt)
                await self.backoff.wait(attempt_num)
                continue

            # Not blocked but didn't work
            attempt.inconclusive = True
            attempts.append(attempt)

        return ExploitResult(
            hypothesis_id=strategy.hypothesis_id,
            confirmed=False,
            attempts=attempts,
        )

    def _rotate_strategy(self, original: ExploitStrategy) -> ExploitStrategy:
        """Create a rotated variant of the strategy."""
        rotation = self.rotator.get_rotation()
        return ExploitStrategy(
            hypothesis_id=original.hypothesis_id,
            method=original.method,
            http_method=original.http_method,
            url=original.url,
            headers={**original.headers, "User-Agent": rotation["user_agent"]},
            body=original.body,
            params=original.params,
            payload=original.payload,
            encoding=rotation["encoding"],
            delivery=rotation["delivery"],
            follow_redirects=original.follow_redirects,
            timeout=original.timeout,
            impersonate=rotation["fingerprint"],
            description=f"Rotated: {rotation['encoding'].value} via {rotation['delivery'].value}",
        )

    @staticmethod
    def _is_success(status: int, body: str) -> bool:
        """Determine if the response indicates exploit success."""
        # Basic heuristics — real implementation would use LLM evaluation
        if status == 0:
            return False
        if 200 <= status < 400:
            return True
        return False

    @staticmethod
    def _is_blocked(status: int, body: str) -> bool:
        """Determine if the response indicates the request was blocked."""
        if status in (403, 406, 429, 503):
            return True
        blocked_indicators = [
            "blocked", "forbidden", "rate limit", "captcha",
            "waf", "firewall", "access denied",
        ]
        body_lower = body.lower()
        return any(ind in body_lower for ind in blocked_indicators)
